# 数据库

## 第一单元

1. **DBAS**：数据库应用系统，包括**DBS**和DBS的应用系统
   **DBS**:数据库系统,包括**DBMS**、**DB**和用户
   **DBMS**:数据库管理系统,是在**DB**和用户之间的一个中间管理
   **DB**:长期存储在计算机内的有组织的和可共享的数据集合,一般储存在硬盘上
2. 数据管理的三个阶段:**人工管理**,**文件系统**,**数据库系统**
3. 数据模型的抽象过程:**现实世界**$\rightarrow$**信息世界**$\rightarrow$**数据世界**
4. 数据模型的分类:**概念数据模型**(现实世界模型,包括E-R图),**逻辑数据模型**(用户从数据库所看到的模型),**物理数据模型**(是对数据最底层的抽象)
5. **实体间的联系**(分为二元和多元联系)根据数目分类:1-1,1-n,M-N
6. E_R图:**方框**表示一个实体集,**菱形框**表示联系,**椭圆框**表示属性
7. E-R图画法:
   1. 通过对现实世界进行分析抽象后,找出需要抽象实体集和属性(需要标注的事物不具有需要描述的属性且不与其它实体集有联系都尽量作为属性)
   2. 找出各实体集之间需要关注的联系
   3. 找出联系的属性
   4. 绘制E-R图从局部到全局
8. **数据模型分类**:
   1. **层次模型**:按层次(树状结构)表示实体与实体间的关系,有且只有一个结点没有双亲结点,其他结点只有一个双亲结点，得到数据时，需要从上到下依次遍历
   2. **网状模型**:在层次模型上有所改良,允许一个以上结点没有双亲结点,允许每一个结点有多个双亲
   3. **关系模型**:由关系和实体组成，可用二维表格存放，数据结构单一，更易理解，现在已规范化，概念简单，操作方便，是目前主要采用的数据模型,可表示为:$R(U,D,DOM,I,\sum)$
   $R$是关系名
   $U$是组成关系$R$的全部属性的集合
   $D$是$U$中属性取值的值域
   $DOM$是属性列到域的映射,即:$DOM:U\rightarrow D$,且每个属性$A_i$所有可能的去值集合构成$D_i(i=1,2,…,n)$,并允许$D_i=D_j$,$i\not ={j}$
   $I$是一组完整性约束条件
   $\sum$是属性集间的一组依赖
   4. **面向对象模型**:是面向对象程序设计方法和数据库技术相结合的产物,最基本的数据概念是对象和类
9. 数据库系统的三级结构:
   1. **概念模式**:简称模式,是由**数据库设计者**综合所有用户数据,按照统一的观点构造的对数据库全局的逻辑结构的描述,模式是型的描述,反映数据的结构和其联系,模式的具体值称为模式的一个实例,反映数据库某一时刻的状态,一个数据库只有一个概念模式,它是数据库系统结构中的中间层
   2. **外部模式**:介于数据库和用户之间,是用户与数据库的接口,是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述
   3. **内部模式**:是对数据库中数据物理结构货物存储方式的描述,是数据在数据库内部的表示方式,一个数据库只有一个内部模式

## 第二单元

1. 关系模型
   1. 关系数据结构
   **域**:是一组具有相同数据结构的值的集合
   **笛卡尔积**
   **关系**:一组笛卡尔积的子集称为一个关系
   **码**:由一个或几个属性组成有如下几个码
   　**候选码**:一个关系中能唯一标识元组的属性或最小属性集称为关系的候选码
   　**主码**:一个关系中有多个候选码,选择其中一个作为主码,包含在任何一个候选码中的属性称为主属性,不包含在任意一个候选码中的属性称为非主属性或非码属性
   　**外码**:设F是基本关系R的一个或一组属性,但不是R的码,k是基本关系S的码,如果F和s对应,则称F是R的外码,并称基本关系R为参照关系,基本关系S为被参照关系
   2. 关系完整性约束
   **实体完整性**:主码属性不能为空或无意义的值
   **参照完整性**:不允许引用一个不存在的实体,或为空,或为存在的值
   **用户自定义完整性**:针对某一数据的特定约束条件
   3. **关系代数**:包括传统的交、并、差和笛卡尔积
   **选择运算**:选择是根据某些条件对关系做选择$\sigma_{筛选的条件}(表名)$
   **投影运算**:消去某些列,并按要求重新排列,再删去相同元组$\prod{属性列}(表名)$
   **连接运算**:将两个关系连接成新关系$A\underset{两表的两属性组比较}\Join B$
   **自然连接**:是连接运算的一种特殊情况,它要求比较的是两个关系中有相同的属性组,并且在结果中把重复的属性列去掉$A \bowtie B$
   **除运算**
   4. 优化策略
   选择先行,合并笛卡尔积和之后的选择操作使之成为连接操作,合并连续的选择和投影

## 第三单元

1. SQL语句分类
   **数据查询**:SELECT
   **数据定义**:CREATE,DROP
   **数据操作**:INSERT,UPDATE,DELETE
   **数据控制**:GRANT,REVOKE
2. 创建表

   ```SQL
   create table `表名`(
      `字段名1` 数据类型(int,float,char(8),etc.) 列级约束条件(primary key,references 表,unique,not null,etc.),
      `字段名2` 数据类型 列级约束条件,
      ......
      //既可用列级约束性条件也可用表级约束性条件
      primary key(字段列表),
      foreign key(字段名) references 表名(字段名)
   );

   //删除表
   DROP table `表名` [RESTRICT | CASCADE]
   restrict 存在视图或约束条件涉及时,无法删除
   cascade 将涉及的对象一并删除 
   ```

3. 修改基本表

   ```SQL
   alter table `表名` ADD 新列名 数据类型 完整性约束 //添加列
                     DROP 完整性约束名 //删除完整性约束
                     ALTER COLUMN 列名 数据类型 //更改列的数据类型
   ```

4. 查询

   ```SQL
   //按次序写下
   select [all | distinct] 属性列表 可用as取别称
   from 表名或视图名列表
   where 条件表达式 \\不能含有函数
   group by 列名 //按某一列的取值分组,有相同取值的为一组
   //group by只有用于分组的属性和函数有意义,即查询的属性列表只有该列和集函数才有意义
   having 条件表达式 //对数据筛选,一般只写函数
   order by 列名 asc|desc(升序|降序),列名 asc|desc //默认升序
   limit 起始行,截止行;
   ```

   查询的条件表达式
   1. 查询谓词

   | 查询条件 | 谓词  |例子|
   |:-:|:-:|:-:|
   |比较|=、<>(不等于)、>、<、>=、<=|成绩=90|
   |算术运算|+、-、*、/|成绩=成绩+1|
   |确定范围|(not)between and|成绩 between 60 and 90(包括60和90)|
   |确定集合|(not)in|学院 in('信电','理学院','计算机')|
   |字符匹配|(not)like|姓名 like '_\%' escape '\\'转义|
   |空值|is (not)null|成绩 is null|
   |多重条件|and、or||
   |左右外连接|+=、=+|带加号的一端元组无论另一端有没有对应都会返回|
   |并|union|将结果集并在一起|
   |any、all|与子查询或集合一起使用,any、all分别意为其中某个值、所有值||
   |(not)EXISTS|只返回true或false,当该元组在子查询中找到配对则保留,否则过滤去||

5. 数据操作
   * 插入

   ```SQL
   INSERT
   INTO 表名(属性列)
   //元组插入
   VALUES(属性1,属性2,...)

   //子查询插入,查询语句
   select 属性1,属性2
   ```

   * 删除

   ```SQL
   DELETE
   FROM 表名
   //删除符合条件的元组
   WHERE 删除条件
   ```

   * 修改

   ```SQL
   UPDATE 表名
   SET 属性1=值,属性2=值,...
   WHERE 修改条件
   ```

   * **数据操作的WHERE语句后面都可以使用子查询**
6. 视图
   * 建立视图

   ```SQL
   create view 视图名(属性)
   as 子查询(select语句)
   [with check option];//使用后,在对视图执行增删改操作时要满足子查询中的条件表达式
   ```

   * 删除视图

   ```SQL
   DROP VIEW 视图名
   ```

   * 视图定义后,允许把视图作为查询的对象
   * 绝大多数的视图都无法更新,即不支持对视图增删改操作

   |具有的特点|INSERT|UPDATE|DELETE|
   |:-:|:-:|:-:|:-:|
   |有属性来自表达式或常数|:x:|:x:|:ballot_box_with_check:|
   |属性来自库函数|:x:|:x:|:x:|
   |定义中有group by|:x:|:x:|:x:|
   |定义中有DISTINCT(select中消去相同行)|:x:|:x:|:x:|
   |嵌套依赖的基本表查询|:x:|:x:|:x:|
   |由多个基本表导出|:x:|:x:|:x:|
   |在以上情况的视图之上定义的视图|:x:|:x:|:x:|

7. 授权

   ```SQL
   GRANT 权限1,权限2 //授什么权,权限后可加括号选择权限可应用的列,主要权限有增删查改
   //如果全部权限都要给予使用all privilege
   ON 对象类型 对象名 //对什么对象
   TO 用户1,用户2 //对什么人
   //若授予所有用户使用TO public
   [with check options]; //能否传下去

   //收回权限,将其授予给其他人的权限一并收回
   REVOKE 权限1,权限2
   ON 对象类型 对象名
   FROM 用户1,用户2;
   ```

## 第四单元

1. 泛关系模型存在问题
   1. 插入异常
   2. 删除异常
   3. 数据冗余
2. 函数依赖和泛式
数据依赖包含函数依赖、多值依赖、连接依赖、分层依赖、相互依赖等,函数依赖最常见
   1. 函数依赖类似数学函数,表示某个值可唯一确定另一个值
   2. 基本概念($X\rightarrow Y$)
      * 决定因素:$X$被称为决定因素
      * 互相依赖:$X\rightarrow Y,Y\rightarrow X$则X和Y相互依赖,记为$X\leftrightarrow Y$
      * 若Y不依赖X,则记$X\nrightarrow Y$
   3. 依赖类型
   **非平凡函数依赖**::$X\rightarrow Y$且$Y\not\subseteq X$,则称非平凡函数依赖
   **完全函数依赖**:$X\rightarrow Y$且x的真子集$X'$都有$X\nrightarrow Y$,则$Y$完全函数依赖$X$,记为$X \stackrel{f}\rightarrow Y$
   **部分函数依赖**:$X\rightarrow Y$但存在x的真子集$X'$使$X\rightarrow Y$,则$Y$部分函数依赖$X$,记为$X \stackrel{p}\rightarrow Y$
   **传递函数依赖**:$X\rightarrow Y(Y\not\subseteq X),Y\nrightarrow X,Y\rightarrow Z$,则$Z$传递函数依赖$X$,记为$X \stackrel{t}\rightarrow Y$
   4. 码的定义
      * **码(候选码)**:设k为R<U,F>中的属性或属性组,若$K \stackrel{f}\rightarrow U$,则k为R的候选码,若候选码多于一个,则选择其中一个作为主码
      * **主属性**:在任意一个候选码中的属性为主属性,其他的为非主属性
      * **全码**:整个元组全为码
      * **外码**:在本关系模式中不为主码,但为另一关系中的主码
      * **超码**:$X \stackrel{f}\rightarrow Y,X\subseteq Y$则称X为超码
   5. 泛式
      1. **第一范式(1NF)**:所有属性不可再分
      2. **第二范式(2NF)**:每个非主属性都完全函数依赖于码
      3. **第三范式(3NF)**:不存在传递函数依赖于码
      4. **BC范式**:每个决定因素都含有码,即每个属性只完全函数依赖于不包含它本身的码

## 第五单元

1. 数据库设计的基本步骤
   1. 需求分析
   2. 概念结构设计
   3. 逻辑结构设计
   4. 物理结构设计
   5. 数据库实施
   6. 数据库运行与维护
2. **E-R图的设计**
   1. 视图集成需解决的问题:由局部合成全局时需解决的问题解决
      * 属性取值不同:相同属性的类型、取值范围、取值集合、单位要确保相同
      * 命名不同:解决同名异义和异名同义问题
      * 结构冲突:在不同应用系统中,同一对象结构要相同
      * 合并视图:人为干预和协商解决冲突
   2. E-R图转换原则
      1. 实体的转换:一个实体转换成一个关系模式,实体的属性就是关系的属性
      2. 联系的转换:
         * 联系为1:1,一般与其中一边的关系模式合并,在该关系模式中加入联系本身的属性和另一边关系模式的码
         * 联系为1:n,一般与n端对应的关系模式合并,加入1端关系模式的码和联系本身的属性
         * 联系为n:n,只能作为一张独立的表,表中加入两端的码和联系本身的属性
      3. 具有相同码的关系模式可以合并

## 第六单元

1. **事务**
   1. 概念:是将一组数据库操作打包起来形成一个逻辑独立的工作单元,这个工作单元不可分割,要么不发生,要么全发生
   2. 事务的特性(ACID):成为事务必须满足这特性
      1. 原子性(Atomicity):事务不可分割的性质
      2. 一致性(Consistency):事务在执行前后数据库都处于一致性状态,即满足完整性约束
      3. 隔离性(Isolation):多个事务并发执行时必须独立
      4. 持久性(Durability):已提交的事务对数据库的修改是永久的持续存在的
2. 数据库恢复
   1. **数据库故障**
      1. **事务内部故障**:当前事务操作执行过程中的错误,分为预期故障(已预估到并加以处理的故障)和非预期故障
      2. **系统故障**:软故障,是指系统停止运转并要求重启的事件
      3. **介质故障**:硬故障,是数据库运行过程中磁盘损坏、强磁场干扰以及其它天灾人祸等导致数据库数据部分或全部丢失的一类故障
      4. **计算机病毒**:可能诱发以上任何一种故障
   2. **实现技术**
      1. 通过转储建立冗余:定期将数据库转储副本,有两种分类方式,静态转储(没有事务运行时的转储)和动态转储(允许事务操作存取或更新),海量转储(全部备份)和增量转储(只转储更新过的数据),因此总共有四种情况
      2. 通过日志文件建立冗余:添加日志文件,要遵循两大原则
         1. 登记的顺序严格按照时间顺序
         2. 必须先写日志,再进行操作,并且日志不能和数据库存放在同一磁盘,要经常复制到稳定的存储设备上

      |日志文档的书写格式|||||
      |:-:|:-:|:-:|:-:|:-:|
      |事务标识|操作类型|对象标识|前像|后像|
   3. 恢复策略:使用最近的备份,再正向扫描日志文件,将新的commit的事务操作加入到redo队列,反向扫描日志文件,将rollback事务操作加入到undo队列,先进行redo队列,在进行undo队列
   4. 优化:在数据库日志中添加检查点,检查之前事件是否完成,只用对最近的检查点未完成事件和新事件重做,就可恢复到故障前的一致性状态
3. **并发控制**
   1. 并发引起的问题:
      1. **丢失修改**:该事务的修改被错误的覆盖
      2. **不可重复读**:在该事务读取数据时,数据已被读取磁盘并在修改值,之后数据被修改,两次数据不一致
      3. **读"脏数据"**:在读取数据时,数据已被另一事件读取修改,之后数据被rollback,读取到了不存在在数据库中的数据,这种不正确的数据被称为脏数据
   2. 调度的串行化
      1. 定义:当一个事务集的并发调度和某一串行化调度等价,则称该并发调度是可串行化的
      2. 串行化方法:前趋图,对于可串行化的事务,图中无回路
      如果事务Ti的读在事务Tj的写之前、
      事务Ti写在事务Tj读之前、
      事务Ti写在事务Tj写之前在前趋图中加入i到j的单向边,如果无回路,必有一个点无入弧,将一个无入弧的结点取出来,会出现另一个无入弧的点,依次取出,可得到对应的串行化调度
   3. **封锁技术**
      1. 排他锁:X锁,一个事务对数据上排他锁,任何事务无法对他上锁,直到事务完成,锁解开,在此期间只有该事务能读取和修改
      2. 共享锁:S锁,上锁后,其他事务只能对他上共享锁,不能上排他锁,只能读

      |能否上锁|X锁|S锁|
      |:-:|:-:|:-:|
      |上了X锁|:x:|:x:|
      |上了S锁|:x:|:ballot_box_with_check:|
      |无锁|:ballot_box_with_check:|:ballot_box_with_check:|
   4. **封锁协议**:

|封锁协议|具体|X锁|s锁|一致性保证|
|:-:|:-:|:-:|:-:|:-:|
|一级封锁协议|在修改前加X锁,在事务结束后释放|事务结束释放|无s锁|不丢失修改|
|二级封锁协议|兼容一级封锁协议X锁,在读取前加s锁,在操作结束后释放|事务结束释放|操作结束后释放|增加了不读脏数据|
|三级封锁协议|在二级协议上做更改,S锁生存周期延长,在事务提交或回滚后释放|事务结束释放|事务结束释放|增加了可重复读|

* 死锁的处理
  * 超时法:对锁进行超时检测,用于时限不好控,容易发生误判
  * 等待图法:类似前趋图求串行化调度,Ti等待Tj有i到j的有向边,如果有回路,说明出现死锁
  * 发现死锁后,选择一个牺牲最小的事务回滚,使其他事务得以进行
* 活锁
  * 一个事务永远处于等待状态,用于许多事务都在不停给该数据上锁,该事务一直得不到执行
  * 解决方法:对先申请的事务先执行,后面事务依次排队
